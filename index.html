<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>I am Rov</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000000;
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #canvas {
            width: 100%;
            height: 70vh;
            cursor: pointer;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            text-align: center;
            color: white;
            z-index: 10;
        }

        input[type="text"], input[type="number"], input[type="color"] {
            padding: 10px;
            font-size: 1rem;
            border: none;
            border-radius: 5px;
            background: rgba(255,255,255,0.1);
            color: white;
            width: 150px;
            margin: 5px;
        }

        button {
            padding: 10px 20px;
            font-size: 1rem;
            background: #00ffff;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }

        button:hover {
            background: #ff00ff;
        }

        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 0.9rem;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }

        .error {
            position: absolute;
            top: 50px;
            left: 10px;
            color: red;
            font-size: 0.9rem;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
    </style>
</head>
<body>
    <div id="canvas"></div>
    <div class="info">
        
    </div>
    <div class="error" id="error">Lỗi: Không thể tải tài nguyên!</div>
 

    <script>
        // Kiểm tra dependencies
        if (!THREE.LuminosityHighPassShader) {
            document.getElementById('error').textContent = 'Lỗi: Không tải được LuminosityHighPassShader!';
            document.getElementById('error').style.display = 'block';
        }

        // Cảnh Three.js
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / (window.innerHeight * 0.7), 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight * 0.7);
        document.getElementById('canvas').appendChild(renderer.domElement);

        // Post-processing cho hiệu ứng glow
        let composer, bloomPass, bloomEnabled = true;
        try {
            composer = new THREE.EffectComposer(renderer);
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight * 0.7),
                1.0, 0.4, 0.85
            );
            composer.addPass(bloomPass);
        } catch (e) {
            document.getElementById('error').textContent = 'Lỗi: Không khởi tạo được bloom effect!';
            document.getElementById('error').style.display = 'block';
            bloomEnabled = false;
        }

        // Ánh sáng
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0x00ffff, 2, 100);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);

        // Lens flare giả lập
        const flareGeometry = new THREE.SphereGeometry(0.1, 16, 16);
        const flareMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5 });
        const flare = new THREE.Mesh(flareGeometry, flareMaterial);
        flare.position.copy(pointLight.position);
        scene.add(flare);

        // Tạo văn bản 3D
        let textMesh, textSize = 1;
        function createTextMesh(text, size) {
            if (textMesh) scene.remove(textMesh);
            const fontLoader = new THREE.FontLoader();
            fontLoader.load(
                'https://threejs.org/examples/fonts/helvetiker_bold.typeface.json',
                (font) => {
                    const geometry = new THREE.TextGeometry(text, {
                        font: font,
                        size: size,
                        height: 0.2,
                        curveSegments: 12,
                        bevelEnabled: true,
                        bevelThickness: 0.03,
                        bevelSize: 0.02,
                        bevelOffset: 0,
                        bevelSegments: 5
                    });
                    geometry.center();
                    const material = new THREE.MeshStandardMaterial({
                        color: 0x00ffff,
                        metalness: 0.8,
                        roughness: 0.2,
                        emissive: 0x00ffff,
                        emissiveIntensity: 0.5
                    });
                    textMesh = new THREE.Mesh(geometry, material);
                    textMesh.userData = { scale: 1, targetScale: 1, shake: 0, pulse: 0 };
                    scene.add(textMesh);
                    document.getElementById('error').style.display = 'none';
                },
                undefined,
                (err) => {
                    document.getElementById('error').textContent = 'Lỗi: Không tải được font! Sử dụng "Rov" mặc định.';
                    document.getElementById('error').style.display = 'block';
                    console.error('Font load error:', err);
                    createFallbackTextMesh(text, size); // Fallback
                }
            );
        }

        function createFallbackTextMesh(text, size) {
            const geometry = new THREE.BoxGeometry(size, size, size * 0.2); // Fallback cube
            geometry.center();
            const material = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0x00ffff,
                emissiveIntensity: 0.5
            });
            textMesh = new THREE.Mesh(geometry, material);
            textMesh.userData = { scale: 1, targetScale: 1, shake: 0, pulse: 0 };
            scene.add(textMesh);
        }
        createTextMesh('I am Rov!', textSize);

        // Tạo nền sao
        const starCount = 100;
        const stars = new THREE.Group();
        for (let i = 0; i < starCount; i++) {
            const geometry = new THREE.SphereGeometry(0.05, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const star = new THREE.Mesh(geometry, material);
            star.position.set(
                (Math.random() - 0.5) * 50,
                (Math.random() - 0.5) * 50,
                (Math.random() - 0.5) * 50
            );
            stars.add(star);
        }
        scene.add(stars);

        // Vị trí camera
        camera.position.z = 5;

        // Điều khiển chuột
        let isDragging = false, rotationSpeed = 0.01;
        let previousMousePosition = { x: 0, y: 0 };
        document.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        document.addEventListener('mousemove', (e) => {
            if (isDragging && textMesh) {
                const deltaMove = {
                    x: e.clientX - previousMousePosition.x,
                    y: e.clientY - previousMousePosition.y
                };
                textMesh.rotation.y += deltaMove.x * 0.005;
                textMesh.rotation.x += deltaMove.y * 0.005;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });
        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Hiệu ứng pulse khi hover
        let isHovering = false;
        document.getElementById('canvas').addEventListener('mouseenter', () => {
            isHovering = true;
            if (textMesh) textMesh.userData.pulse = 0.2;
        });
        document.getElementById('canvas').addEventListener('mouseleave', () => {
            isHovering = false;
            if (textMesh) textMesh.userData.pulse = 0;
        });

        // Điều khiển phím
        document.addEventListener('keydown', (e) => {
            if (textMesh) {
                if (e.key === 'ArrowLeft') textMesh.rotation.y += 0.1;
                if (e.key === 'ArrowRight') textMesh.rotation.y -= 0.1;
                if (e.key === 'ArrowUp') textMesh.rotation.x += 0.1;
                if (e.key === 'ArrowDown') textMesh.rotation.x -= 0.1;
                if (e.ctrlKey && e.key === 'ArrowUp') camera.position.z -= 0.1;
                if (e.ctrlKey && e.key === 'ArrowDown') camera.position.z += 0.1;
            }
        });

        // Bật/tắt bloom
        function toggleBloom() {
            bloomEnabled = !bloomEnabled;
        }

        // Cập nhật tên
        function updateName() {
            const input = document.getElementById('nameInput').value.trim();
            const size = parseFloat(document.getElementById('sizeInput').value) || 1;
            rotationSpeed = parseFloat(document.getElementById('speedInput').value) || 0.01;
            const color = document.getElementById('colorInput').value;
            if (!input) {
                document.getElementById('error').textContent = 'Lỗi: Vui lòng nhập tên!';
                document.getElementById('error').style.display = 'block';
                return;
            }
            if (textMesh) {
                textSize = Math.max(0.5, Math.min(2, size));
                createTextMesh(input, textSize);
                textMesh.material.color.set(color);
                textMesh.material.emissive.set(color);
                textMesh.userData.targetScale = 1.2;
                textMesh.userData.shake = 0.3;
                textMesh.userData.pulse = isHovering ? 0.2 : 0;
            }
        }

        // Animation loop
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            if (textMesh) {
                textMesh.rotation.y += rotationSpeed;
                textMesh.rotation.z = Math.sin(time) * 0.05;
                textMesh.userData.scale += (textMesh.userData.targetScale - textMesh.userData.scale) * 0.1;
                if (textMesh.userData.pulse > 0) {
                    textMesh.userData.scale += Math.sin(time * 5) * 0.02 * textMesh.userData.pulse;
                }
                textMesh.scale.setScalar(textMesh.userData.scale);
                if (textMesh.userData.shake > 0) {
                    textMesh.position.x = (Math.random() - 0.5) * textMesh.userData.shake;
                    textMesh.position.y = (Math.random() - 0.5) * textMesh.userData.shake;
                    textMesh.userData.shake *= 0.9;
                }
            }

            // Di chuyển sao
            stars.children.forEach(star => {
                star.position.z += 0.05;
                if (star.position.z > 25) star.position.z -= 50;
            });

            // Ánh sáng động và lens flare
            time += 0.02;
            pointLight.position.set(5 * Math.sin(time), 5, 5 * Math.cos(time));
            flare.position.copy(pointLight.position);
            flare.scale.setScalar(1 + Math.sin(time * 2) * 0.2);

            // Render
            if (bloomEnabled && composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }
        animate();

        // Xử lý resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / (window.innerHeight * 0.7);
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight * 0.7);
            if (composer) composer.setSize(window.innerWidth, window.innerHeight * 0.7);
        });
    </script>
</body>
</html>
